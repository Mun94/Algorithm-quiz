/*
* 각 바구니에 담긴 공의 개수가 모두 달라야 한다.
* 가장 많이 담긴 바구니와 가장 적게 담긴 바구니의 공의 개수 차이가 최소가 되려면
* 공의 개수를 최대한 연속적이게 만들면 된다.
* ex.
*   n = 20, k = 5 이면 2, 3, 4, 5, 6 = 20 / 6 - 2 = 4
*   n = 17, k = 5 이면 1, 2, 3, 5, 6 = 17 / 5 - 1 = 4
*   n = 16, k = 5 이면 1, 2, 3, 4, 6 = 16 / 6 - 1 = 5
*   n = 15, k = 5 이면 1, 2, 3, 4, 5 = 15 / 5 - 1 = 4
* */
let test = `17 5`;

let [n , k] = test.split(' ').map(Number);

const sum = (k * (k + 1)) / 2; // 1 ~ k 까지의 합

if (sum > n) {
  console.log(-1); // 공의 개수가 부족한 경우
} else {
  n -= sum;

  if (n % k === 0) {
    console.log(k - 1); // 공의 개수를 최대한 연속적으로 했을 때 공의 개수가 딱 맞는 경우
  } else {
    console.log(k); // 공의 개수를 최대한 연속적으로 했을 때 공의 개수가 딱 맞지 않는 경우
  }
}